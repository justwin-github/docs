var suggestions=document.getElementById('suggestions');var userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(e){if(e.keyCode===191){e.preventDefault();userinput.focus();}
if(e.keyCode===27){userinput.blur();suggestions.classList.add('d-none');}}
document.addEventListener('click',function(event){var isClickInsideElement=suggestions.contains(event.target);if(!isClickInsideElement){suggestions.classList.add('d-none');}});document.addEventListener('keydown',suggestionFocus);function suggestionFocus(e){const focusableSuggestions=suggestions.querySelectorAll('a');const focusable=[...focusableSuggestions];const index=focusable.indexOf(document.activeElement);let nextIndex=0;if(e.keyCode===38){e.preventDefault();nextIndex=index>0?index-1:0;focusableSuggestions[nextIndex].focus();}
else if(e.keyCode===40){e.preventDefault();nextIndex=index+1<focusable.length?index+1:index;focusableSuggestions[nextIndex].focus();}}
(function(){var index=new FlexSearch({preset:'score',cache:true,doc:{id:'id',field:['title','description','content',],store:['href','title','description',],},});var docs=[{id:0,href:"https://docs.just.win/docs/overview/prediction-markets/",title:"Prediction Markets",description:"",content:"\u003cdiv class=\"alert alert-warning d-flex\" role=\"alert\"\u003e\n  \u003cdiv class=\"flex-shrink-1 alert-icon\"\u003eðŸ’¡\u003c/div\u003e\n  \u003cdiv class=\"w-100\"\u003eSir Francis Galton was one of the first to write about the Wisdom of crowds when he found that the the average estimate of villagers as to the weight of an ox was close to the true weight. \u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003ePrediction markets have been \u003ca href=\"https://blog.gnosis.pm/the-power-of-prediction-markets-fedea0b71244\"\u003edefined\u003c/a\u003e as:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSometimes called information markets, idea futures, event derivatives, decision markets, or virtual stock markets, prediction markets are exchange-traded markets where individuals trade the outcome of a future event in the form of event contracts. These event contracts specify the different possible outcomes of a future event, the payment structure based on those outcomes, and the contract\u0026rsquo;s expiration date.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePrediction markets have proven to be a powerful tool in determining the outcome of events. They enable market participants with diverse sets of knowledge to wager on an uncertain outcome, such as who will win the next US election or who will win the FIFA World Cup.\u003c/p\u003e\n\u003cp\u003eThere is a lot of value in being able to quantify estimates of the future. They could even become a cornerstone of government. The concept of \u003ca href=\"https://en.wikipedia.org/wiki/Futarchy\"\u003efutarchy\u003c/a\u003e was inspired by the ability of prediction markets to estimate the future:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eelected officials define measures of national wellbeing, and prediction  \u003ca href=\"https://en.wikipedia.org/wiki/Prediction_market\"\u003emarkets\u003c/a\u003e are used to determine which policies will have the most positive effect\u003cbr\u003e\nLast but not least, prediction markets are also fun and sometimes even profitable. The online betting and gambling industry is estimated to worth \u003ca href=\"https://www.statista.com/statistics/270728/market-volume-of-online-gaming-worldwide/\"\u003e60 billion dollars\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n"},{id:1,href:"https://docs.just.win/docs/overview/automated_market_makers/",title:"Automated Market Makers",description:"A brief summary on automated marketmakers.",content:"\u003cp\u003eOne of the important trends of 2020 was the rise of \u003ca href=\"https://medium.com/dragonfly-research/what-explains-the-rise-of-amms-7d008af1c399\"\u003eautomated market makers\u003c/a\u003e. These automated market makers have been successful in functioning as decentralised exchanges and have attracted billions of dollars in trading volume.\u003c/p\u003e\n\u003cp\u003eThe appeal of these automated market makers is that they are computationally more simple than decentralised orderbook exchanges (such as Etherdelta) and thus allow for more gas efficient trading. Importantly, they are permissionless, allowing anyone to list asset pairs or trade.\u003c/p\u003e\n\u003cp\u003eMost popular decentralised exchanges use \u003ca href=\"https://medium.com/bollinger-investment-group/constant-function-market-makers-defis-zero-to-one-innovation-968f77022159\"\u003econstant product market makers\u003c/a\u003e to provide price quotes for assets. These have their drawbacks, such as impermanent loss, but have overall found a strong product market fit. Many decentralised prediction markets, such as \u003ca href=\"http://omen.eth.link/\"\u003eOmen\u003c/a\u003e and \u003ca href=\"https://polymarket.com/\"\u003ePolymarket\u003c/a\u003e, have adopted the same constant product market maker approach.\u003c/p\u003e\n\u003cp\u003eHowever, the issue with constant product market makers in prediction markets is that since the markets tend to resolve to 0 or 1 in a sudden manner, liquidity providers are often stuck with significant losses. This means that liquidity providers have little incentive to provide liquidity to these prediction market pools, leading to illiquid markets that are not comparable to centralised order book based prediction markets.\u003c/p\u003e\n\u003cp\u003eIn current implementations, liquidity providers are effectively paying for users to divulge information about their beliefs on the outcome of a particular event. This provides an effective means for market makers to crowdsource information about a particular topic such as guessing the weight of Galton\u0026rsquo;s ox. However, this does not incentivise trading volume. If liquidity providers are rewarded only with a percentage of trading fees, then the majority of liquidity providers will lose money from their initial capital.\u003c/p\u003e\n\u003cp\u003eIn order for prediction markets to be successful, we need to promote liquid markets by ensuring that LPs are adequately rewarded for providing liquidity. We believe that the best way to do this is by designing AMMs that reward the creation of markets and minimise the risks associated with providing liquidity .Constant product automated market makers are just one type of automated market maker, and it is possible that different families of automated marketmaker serve the prediction market model better.\u003c/p\u003e\n"},{id:2,href:"https://docs.just.win/docs/overview/conditional_token/",title:"Conditional Token Framework",description:"",content:"\u003cp\u003eThe \u003ca href=\"https://docs.gnosis.io/conditionaltokens/\"\u003econditional tokens framework\u003c/a\u003e is a set of audited contracts published by gnosis which can allow for the creation of prediction markets. These contracts have their own extensive \u003ca href=\"https://docs.gnosis.io/conditionaltokens/docs/devguide01/\"\u003edocumentation\u003c/a\u003e.Â \u003c/p\u003e\n\u003cp\u003eIn essence, a user is able to create a condition. This condition represents a particular question and has a number of parameters. These parameters are set using the setup() function and explained below:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eOracle. This is an address and represents how the outcome of the question will be determined. This can either be an externally owned account or a smart contract. We discuss this further on the \u003cem\u003eoracle\u003c/em\u003e page.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOutcome slot count.  This is an integer and represents how many different discrete outcomes are available for the question.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"},{id:3,href:"https://docs.just.win/docs/overview/oracles/",title:"Oracles",description:"",content:"\u003cp\u003eWithin this page, we will describe different approaches to solve the oracle problem. If you want to know how to implement these within the prediction markets, please see the development page.\u003c/p\u003e\n\u003cp\u003eThe oracle problem has been well documented within blockchain technology. Blockchain networks are designed in such a way as to be deterministic. This makes it easy to access data that is stored on-chain (such as checking the balance of a public address) but impossible to access off-chain data (such as the weather in California).Â \u003c/p\u003e\n\u003cp\u003eAn oracle acts as a bridge for this real-world data and offers an approach for bringing this data on-chain. There are multiple different oracle solutions and each has their own benefits/issues. We will discuss a number of different oracles that can be used to power prediction markets, although this list is not exhaustive.\u003c/p\u003e\n\u003ch3 id=\"the-trusted-data-source\"\u003eThe trusted data source\u003c/h3\u003e\n\u003cp\u003eA user can be nominated as the source of oracle information. This is the easiest oracle solution to implement. To give an example, I could create a prediction market with the question \u0026ldquo;Who will win the 2022 World Cup?\u0026rdquo; which has 32 different outcomes. After the tournament is over, I could submit a transaction onto the conditional tokens contract calling the function reportPayouts().\u003c/p\u003e\n\u003cp\u003eThe main issue with this approach is that it relies on a trusted party to honestly submit the correct outcome. It is easy to imagine situations where this architecture can be abused by malicious actors.\u003c/p\u003e\n\u003ch3 id=\"the-objective-data-oracle\"\u003eThe objective data oracle\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://chain.link/\"\u003eChainlink\u003c/a\u003e is one example of a decentralised solution to the oracle problem and can be implemented with prediction markets to safely determine the outcome of an event. Broadly speaking, chainlink utilises a network of nodes to access off-chain data and submits this information on-chain for smart contracts to utilise. It is easy to implement price feed oracles from chainlink so it is possible to create prediction markets such as \u0026ldquo;Will the price of Bitcoin be greater than $100,000 by the end of 2021\u0026rdquo;. It is also possible to interface with external adaptors using chainlink in order to obtain any data that can be found in an API.\u003c/p\u003e\n\u003cp\u003eThere are limitations using chainlink in the type of data available. It is easy to obtain discrete data such as price feeds or sports scores, but difficult to establish outcomes where there may be conflicting data sources.\u003c/p\u003e\n\u003ch3 id=\"the-subjective-data-oracle\"\u003eThe subjective data oracle\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://kleros.io/\"\u003eKleros\u003c/a\u003e provides a decentralised dispute resolution service and can also be used as a \u0026lsquo;subjective oracle\u0026rsquo;. When utilising kleros, a number of jurors must vote and decide on the outcome and are financially incentivised for choosing the correct outcome. This is particularly important when there may be conflicting information from different sources of data. Kleros \u003ca href=\"https://thedailychain.com/case-302-a-moment-in-decentralized-history/\"\u003ecase 302\u003c/a\u003e is the most notable example of this happening.\u003c/p\u003e\n"},{id:4,href:"https://docs.just.win/docs/overview/lsmr/",title:"LSMR \u0026 LS-LSMR",description:"",content:"\u003ch2 id=\"lmsr\"\u003eLMSR\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"http://mason.gmu.edu/~rhanson/mktscore.pdf\"\u003eLogarithmic Market Scoring Rules\u003c/a\u003e (LMSR) market maker has a rich academic historyÂ  and was designed specifically with prediction markets in mind.\u003c/p\u003e\n\u003cp\u003eAccording to the \u003ca href=\"https://docs.gnosis.io/conditionaltokens/docs/introduction3/\"\u003eGnosis Developer Portal\u003c/a\u003e the advantages of the LSMR compared to the CPMM are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eLMSR has more recognition in academic work, and its properties are much more studied than CPMM. It is easier to find papers on the properties of LMSR, or to leverage existing research on this market maker.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eLMSR breaks down into self-similar components when applied to combinatorial prediction markets. Its analysis in those scenarios has been quite explored in the literature.Â \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFinally, the closed form expressions for buying and selling with the LMSR allow calculating a net cost for a batch of buys and sells done simultaneously. The CPMM does not admit such an expression for the prediction market use case, so buying and selling is limited on the contract to one outcome token at a time.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNonetheless, there are only two projects that we know of that have implemented an LMSR market maker. These are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/gnosis/conditional-tokens-market-makers\"\u003eGnosis implementation\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/charmfinance/charm-options\"\u003eCharm.fi implementation\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"ls---lmsr\"\u003eLS - LMSR\u003c/h2\u003e\n\u003cp\u003eThe liquidity sensitive LMSR (LS-LMSR) AMM algorithm was described by Othman et al. 2013 (\u003ca href=\"https://www.cs.cmu.edu/~./sandholm/liquidity-sensitive%20automated%20market%20maker.teac.pdf\"\u003eA Practical Liquidity-Sensitive Automated Market Maker\u003c/a\u003e) and offers an improvement on the traditional LMSR algorithm.\u003c/p\u003e\n\u003cp\u003eFor our purposes, this algorithm has the following desirable properties:Â \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eCan be used as a price oracle for tokens using the conditional token framework (CTF).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBounded loss can be set as a parameter, such that the downside to liquidity providers is limited.Â \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOverrounding can also be set as a parameter. This is the main function that helps LPs achieve profits.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"advantages\"\u003eAdvantages\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eSimilar UX to Uniswap LP-ing, familiar to DeFi users. However, the downside is much less complex to estimate than in Omen or in Uniswap\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMarket depth increases with trading volume -\u0026gt; less spread for more popular markets\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUser that creates market does not need to set initial probabilities of outcomes\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFunctions well in both low and high liquidity markets (dynamically adjusts the b parameter from the LMSR based on liquidity such that low liquidity markets have larger spread)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"disadvantages\"\u003eDisadvantages\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eDoes not easily allow users to sell their outcome tokens back to the AMM\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBounded loss makes for a better UX, but is capital inefficient.Â \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDoes not respond to market shocks well (ie if a presidential candidate pulls out)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRequires the initial probabilities to be equal at initialisation - there will be immediate arbitrage opportunities for traders at initialisation\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePrices do not converge to a well defined probability estimate, but instead fluctuate about an equilibrium price\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eProfit-taking is fixed regardless of liquidity -\u0026gt; therefore in the larger popular markets (such as the result of an election), prices will be greater than those offered on centralised exchangesÂ \u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAMM cannot re-buy tokens from users at the same price\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs far as we know, no live project currently uses an LS-LMSR. The Charm.Fi team implemented one for their decentralised trading platform, but decided to use the LMSR instead.\u003c/p\u003e\n"},{id:5,href:"https://docs.just.win/docs/tutorial/getting-started/",title:"Getting Started",description:"How to start with our AMMs.",content:"\u003cp\u003eWe have provided our smart contracts in two formats:Â \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eA \u003ca href=\"https://gist.github.com/abdullathedruid/f58f51e3253dde53c068e71864348274\"\u003egist\u003c/a\u003e that can be readily imported into remix IDE. This consists of a single flattened solidity file which you can immediately deploy and play with. Our tutorial will utilise this, and can be followed with minimal programming knowledge.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFull \u003ca href=\"https://github.com/abdullathedruid/lslmsr\"\u003egithub repository\u003c/a\u003e. We expect users with some development experience will be able to utilise this to empower their own contracts. Furthermore, we would welcome any modifications to the contract.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n"},{id:6,href:"https://docs.just.win/docs/tutorial/import-into-remix/",title:"Import into Remix",description:"How to import into Remix.",content:"\u003cp\u003e\u003ca href=\"https://remix.ethereum.org/\"\u003eRemix\u003c/a\u003e is a browser ethereum IDE and will be utilised for this tutorial.\u003c/p\u003e\n\u003cbr\u003e\n\u003cimg src=\"https://lh6.googleusercontent.com/FP3y1YVOgR1UEvw6ABpka3BFt7oli9mBDBBjfpPMNlOZranDskMsxxFY2iu3Y5O5UBU3Xu3MePm5NGFR6jBoNuGbO3TyVmnNv3aCD9VLhjG6BwnmtcSqtiiSOBMpgt4gz2SUTdFY\" alt=\"compile\" width=\"100%\"/\u003e\n\u003cbr\u003e\n\u003cp\u003eYou will be greeted with this page and can click on \u0026ldquo;gist\u0026rdquo; in order to import the smart contracts.\u003c/p\u003e\n\u003cp\u003eIn the message box that pops up, you can enter the URL for the gist which is found at: \u003ca href=\"https://gist.github.com/abdullathedruid/f58f51e3253dde53c068e71864348274\"\u003ehttps://gist.github.com/abdullathedruid/f58f51e3253dde53c068e71864348274\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eYou should be able to see the full source code at this point. Congratulations!\u003c/p\u003e\n\u003cp\u003eYou can now move on to the next page to deploy the contracts.\u003c/p\u003e\n"},{id:7,href:"https://docs.just.win/docs/tutorial/deploying-contracts/",title:"Deploying Contracts",description:"",content:"\u003cp\u003eIn order to deploy this contract, you will first need to compile the source code. To do this, you will need to open the compiler tab and then select a compiler version from the drop down box. As you can see from the screenshot, we are using version 0.6.6.\u003c/p\u003e\n\u003cp\u003eWhen you click the compile button you should get a number of yellow cautions, but no warning messages.Â \u003c/p\u003e\n\u003cimg src=\"https://lh4.googleusercontent.com/O-eJE005w53BHnEP8eFHw6vKU5wQ1lOY-F3RcqdR_ycOPD-BqtwPU5gxtthyJiIWaQm0_0C-qQFfO_ulNvXRwqqQXtTN-oMJx2exRR4B7vFF68qrFyeqlYFYswyM1QMhgIHG0Be-\" alt=\"compile\" width=\"100%\"/\u003e\n\u003cp\u003eOnce you have successfully compiled the contract, you can begin to deploy the contracts.\u003c/p\u003e\n\u003cp\u003eTo do this, you can click on the deploy and run transactions tab. There is a dropdown menu here called \u0026lsquo;contract\u0026rsquo; which has all the different contracts within the source code. The important contract here is the LsLMSR contract which you can select.\u003c/p\u003e\n\u003cimg src=\"https://lh6.googleusercontent.com/QP0pXWZToc1G08Smm6hmfgkwCu1O4Dsc_bXsw99xNZeiZHw6LBJkvvmlkb6NQoyDBPGpQ8kJUtTgrYp7dPWwf88c95VWKGsBS7Q7Qho-JnW3PA57GgNPs6EBXcTErxh-W4B33nWi\" alt=\"deploy\" width=\"100%\"/\u003e\n\u003cp\u003eYou will notice when you select the LsLMSR that a text box appears. You can click the down arrow and it will expand to show you some more information. When deploying the LsLMSR contract, you are required to provide two addresses. The first address is for the conditional tokens contract, and the second address is for the token that you are using for the base currency.\u003c/p\u003e\n\u003cp\u003eWe will be testing the contract locally first, so we will need to create our own copy of the conditional tokens contract. To do this, we need to select the conditional tokens contract from the drop down box. There will be a text field asking you for the gas limit. You need to set this to 7000000 otherwise you will get an error message.\u003c/p\u003e\n\u003cimg src=\"https://lh3.googleusercontent.com/qHEPo-V0DnLM-6zn_jg1koHA1xwa3mAi6HoAQ2fmtLBFaZ4XpPO19xTuCehDn9Esr7ovkirvKsZO1mRAlzWNWocbdIJwAOT1mHDnIR9H6a6dbrlMTctzVW2w6okQvhHy7l3Yw4AX\" alt=\"error_msg\" width=\"100%\"/\u003e\n\u003cp\u003eOnce you have deployed the contract, you should see the following:\u003c/p\u003e\n\u003cimg src=\"https://lh5.googleusercontent.com/piN72EirtelwEq_ze3r3NS8SEnm4vmzfQdqY_DYugqVlgltIm2I9B_cbBqykbGmDpmp5xyCjIMMMPgqEr7hir1RiI1slTIYX_WPzzzGt6lz1gjRVQB-_FJTIMvKVT5CmUwiX23wf\" alt=\"after_deploy\" width=\"100%\"/\u003e\n\u003cp\u003eYou can click on the clipboard to copy the address for this contract.\u003c/p\u003e\n\u003cp\u003eYou will need to repeat the same process with the FakeDai contract. If you have done this successfully it should look like:\u003c/p\u003e\n\u003cimg src=\"https://lh4.googleusercontent.com/EQxkFUTi4XqWmLxIZZk7XDGgnR02Sv2tMxXbb68hQDAtPg-_PbO2NqWohTs59wBDLnsmGtBclQm7sZOmUOeDXWb6kOJnlmbT6Xyz-s8JgwkPqU0i2s8mTqGFQ33Tfj0bVp_MMJZU\" alt=\"fake_dai\" width=\"100%\"/\u003e\n\u003cp\u003ePlease note that the addresses are determined randomly, so your addresses should look different to mine.\u003c/p\u003e\n\u003cp\u003eNow that you have the addresses for the conditional tokens contract and your ERC20 currency contract, you will be able to deploy your prediction market contract!\u003c/p\u003e\n\u003cp\u003eTo do this, go back to the LsLMSR contract and then input the addresses into the textfield before you deploy. It should look something like this:\u003c/p\u003e\n\u003cimg src=\"https://lh5.googleusercontent.com/Mx_YDwOfAmGjwJ5chsY-gWS6TPgWrQ1MtSO1rs24ta1gu1osEYPuIg2l0O3Vu_OKpvLATxuucevd4Yj0bLtnpU3tyIejSOqLLuIuM-7aXdx0mOriDPUfk_JyAuZoaefBpEaY3KnQ\" alt=\"lsLMSR\" width=\"100%\"/\u003e\n\u003cp\u003eOnce you submit this transaction, you will have successfully deployed the necessary contracts! You can now move onto the next page to interact with the contracts.\u003c/p\u003e\n"},{id:8,href:"https://docs.just.win/docs/tutorial/interacting-with-contracts/",title:"Interacting with contracts",description:"",content:"\u003cp\u003eYou should now have deployed three contracts: The LsLMSR, FakeDai, and ConditionalTokens contracts. When we set up the LsLMSR contract, we will need to fund the contract with some initial liquidity. Therefore we will need to get some money before we can proceed with the set up!\u003c/p\u003e\n\u003ch3 id=\"creating-tokens-to-play-with\"\u003eCreating tokens to play with\u003c/h3\u003e\n\u003cp\u003eIf you click on the deployed instance of the FakeDai contract, you should have a number of functions available. The orange functions are transactions that you can send, whilst the blue functions are view functions.Â \u003c/p\u003e\n\u003cimg src=\"https://lh3.googleusercontent.com/o1a_A8BGcumEd6-MIYGyZcHO28DRCn37lR2WTkrw80cR0vcbfCUgQ-FN_LINXLlIlNOvEwQW-0IWgtDFofyW7NiFdoDvnoQ81g6feTFhFNuVxxCIAH9heF812758c13xli66lUii\" alt=\"compile\" width=\"100%\"/\u003e\n\u003cp\u003eThese functions are found on all ERC20 token contracts with the exception of the mint function. This mint function is a debugging function and takes two parameters, the \u0026lsquo;account\u0026rsquo; and the \u0026lsquo;amount\u0026rsquo;. You will need to enter your address in order to receive the tokens, this address can be found near the top of the remix interface. The \u0026lsquo;amount\u0026rsquo; that you enter will need to include the appropriate number of decimals for the token you are using. If we want to create 1000 Dai (which has 18 decimals), we will therefore need to put the amount as 100000000000000000000.Â \u003c/p\u003e\n\u003cp\u003eYou can confirm that this worked by calling the balanceOf function and inputting the same address. This should output the same number.\u003c/p\u003e\n\u003cp\u003eNow that you have minted 1000 Dai, you need to allow the LsLMSR contract to spend this money. You will need to call the approve() function and input the address of the LsLMSR contract as the spender and the amount as the total amount that you will want to spend. Let us approve 1000 Dai. For me this looks like:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://lh6.googleusercontent.com/AiSB8MrkMiYJ51SSUAS0kQNP_Xm5qoMphZ1P0ui6quTNC5XwkMD6qcv22ZMT65YaGiOLk2AL6S_vGkpAW58jzOwocaAiDv44Nn5V40vuUZ2ZfDQpAFXkDl9UDdBB8vlZqjhsTB7P\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch3 id=\"setting-up-the-lslmsr\"\u003eSetting up the LsLMSR\u003c/h3\u003e\n\u003cp\u003eNow you will need to select the LsLMSR and run the setup() function. This has a number of parameters which we will discuss:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://lh4.googleusercontent.com/uPamXuVj6xYZVsv242pvZTejn92v5T8IFlgh3cTLdtCq2F6HfP9NCF5dX1h2Z_AlrE296v3LWFBdtGLulYKcf6-uaPoAXo4PDpniYSXDb0Am3BJXTuPetEjLLxBY_iSCOlKKBGWb\" alt=\"\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e_oracle will be an address that refers to either an externally owned address, or a smart contract. The prediction market will remain open until this oracle address tells the prediction market what the outcome of the event was. We invite you to read the oracle page for different ideas of what to put here. For our testing purposes, we can use the address for our account. This will be easy for us to report the outcome at the end of our tutorial\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e_numOutcomes is an integer which represents the number of different outcomes that are available. For example, the number of outcomes for a football match would be 3: home team win, away team win, draw. It is worth mentioning at this point, that the conditional tokens allow users to bet on combinations such as either home team winning or draw occurring however the number of discrete outcomes remains 3.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e_subsidy is an integer which represents how much initial funding is available for the prediction market in order to create the prices. There is a trade-off to be made within the LsLMSR algorithm. More initial funding results in a more liquid market, however it increases the potential losses as the bounded loss is proportional to the initial liquidity.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e_overround is an integer which represents how much \u0026lsquo;profit\u0026rsquo; will be taken by the market maker. This number is represented in \u0026lsquo;bips\u0026rsquo; where 100 is equal to 1% profit. If you wish to add 4.5% overround, you would therefore need to enter 450. Traditional book makers would tend to use values between 5 and 10% depending on the nature of the market.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet us make a prediction market for the Superbowl.\u003c/p\u003e\n\u003cp\u003e_oracle will be our address. This means that we will be responsible for correctly reporting on the outcome after the superbowl.\u003c/p\u003e\n\u003cp\u003e_numOutcomes will be 3: For Buccaneers win, Chiefs win, draw.Â \u003c/p\u003e\n\u003cp\u003e_subsidy will be 1000000000000000000000 - this represents 1000 Dai in initial funding\u003c/p\u003e\n\u003cp\u003e_overround will be 450. This books us 4.5% profit\u003c/p\u003e\n\u003cp\u003eYour setup will look like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://lh5.googleusercontent.com/_BVFTPIiCAhmuoQ6kKIB8_MyHnYzemQubty6cAN7utmf7V928qORIzKSdYLGaeYu6hzGyLWnymdylxJfNQAeocZYFU9UlQPaEsYPAXOpgmjoWFHglX6zfRe_PV_34nf5G1KeDk-0\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eOnce you submit this transaction, the prediction market will be ready for users to interact with!\u003c/p\u003e\n\u003ch3 id=\"buying-outcome-tokens\"\u003eBuying outcome tokens\u003c/h3\u003e\n\u003cp\u003eThe buy() function is used to purchase outcome tokens. This function has two parameters which require some additional steps to calculate: the outcome, and the amount.\u003c/p\u003e\n\u003cp\u003eIn order to know what to put for _outcome, we need to briefly discuss how the conditional tokens contract represents each outcome. We have established that we have chosen three discrete outcomes for our event. If we assume the following outcomes:\u003c/p\u003e\n\u003cp\u003eOutcome 1: Buccaneers win\u003c/p\u003e\n\u003cp\u003eOutcome 2: Chiefs win\u003c/p\u003e\n\u003cp\u003eOutcome 3: Draw\u003c/p\u003e\n\u003cp\u003eWe can therefore construct a position based on any combination of these outcomes. If we think that the chiefs will win but also that there may be a draw, then we will purchase tokens for outcomes 2 and 3. Conditional tokens allow us to have a position in both these outcomes by combining the outcomes into a collection. Outcomes that will be included within the collection will be represented in binary with a 1. We can therefore construct:\u003c/p\u003e\n\u003cp\u003eOutcome 1: 0\u003c/p\u003e\n\u003cp\u003eOutcome 2: 1\u003c/p\u003e\n\u003cp\u003eOutcome 3: 1\u003c/p\u003e\n\u003cp\u003eThis can be expressed in binary as 0b110. Note that this is backwards where the first 1 represents outcome 3. 0b110 as an integer is 6.Therefore, if we wish to purchase tokens for Chiefs winning or there being a draw, we will need to put _outcome as 6.\u003c/p\u003e\n\u003cp\u003eThe _amount represents the amount of tokens that we wish to purchase. It is worth mentioning at this point that 1 outcome token pays out 1 of the base currency. Although the price of underlying base currency can fluctuate, the outcome tokens will always be proportional to the price of the underlying. The _amount is submitted as a fixed point integer. This is the desired number multiplied by 2^64. If you wish to purchase one outcome token, you will therefore need to enter 18446744073709551616.\u003c/p\u003e\n\u003cp\u003eLet us purchase outcome tokens that will pay out 10 Dai if the Chiefs win or draw. We will therefore need to enter:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://lh4.googleusercontent.com/8vIHGuNt9scsc71rT-ERen_IrgOAvYAxvnf9DwMtdOe3cDSCuC0GQyriaLsP_0SQA5NjMdoZQjx7bAhb768McoauIRZK1JQbXlJmBNidH50NGG9cDP8bpWz_CgWZMvGch0DuNvOV\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eNote the 0 at the end of _amount to signify ten outcome tokens.\u003c/p\u003e\n\u003cp\u003eIf you followed the tutorial, you should have received an error message telling you \u0026ldquo;ERC20: transfer amount exceeds balance\u0026rdquo;. See if you can mint some more dai, and then approve this to be spent again and re-try!\u003c/p\u003e\n\u003cp\u003eCongratulations, you\u0026rsquo;ve just bought your tokens from the market maker.\u003c/p\u003e\n\u003ch3 id=\"reporting-payout-and-claiming-rewards\"\u003eReporting payout and claiming rewards\u003c/h3\u003e\n\u003cp\u003eAs we set the oracle for the contract to be our address, we are able to set the outcome of the market. We do this by calling the reportPayouts() function found within the conditional tokens contract. We must input the questionId and the outcome.\u003c/p\u003e\n\u003cp\u003eThe questionId will be the address of the LsLMSR contract. You need to convert this into bytes32 notation and can do this with the AddToBytes() function found within the LsLMSR. For me, this looks like 0x000000000000000000000000d7acd2a9fd159e69bb102a1ca21c9a3e3a5f771b and is simply the address padded with an appropriate number of zeros.\u003c/p\u003e\n\u003cp\u003eThe payout variable takes an array of the relative payout for each outcome. As we chose three outcomes, we will need to enter an array with three variables here. If you wanted to report that the Chiefs won, you will enter this outcome as a 1 (which means each outcome token can be redeemed for 1 base currency) and the rest as zero.Â \u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://lh4.googleusercontent.com/oaoc1rOrI99WmV97cEG2gpDtik1cgjOmRux5Pu7eXEcK-Oj43159ec6S53PxL9wYphZgJy1MV65t5Pun2jnTK0c0dNsmWjsvfwl3ha0RPQcDmX89cwhnNqHqFLE3G7tr8lpeCLGu\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eNow that you have done this, you can claim your reward for the successful portion of your position. You do this with the redeemPositions() function. This function takes your outcome tokens and then converts them back into the base currency token. The redeemPositions() function takes the following parameters:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ecollateralToken: the address for the ERC-20 token used\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eparentCollectionId: this will be 0x0000000000000000000000000000000000000000000000000000000000000000\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003econditionId: this can be found by clicking on the \u0026lsquo;condition\u0026rsquo; button within the LsLMSR contract or calculated by the getConditionId() function on conditional tokens\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eindexSets: this will be the same number as the integer representation of your positions, displayed as an array. For us this will be [6]\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you check your balance of collateral token, you should notice that you have more dai than when you started!\u003c/p\u003e\n"},{id:9,href:"https://docs.just.win/docs/tutorial/deploying-to-testnet/",title:"Deploying to Testnet ",description:"Lorem ipsum Description.",content:"\u003cp\u003eYou are able to deploy the contracts to any network using remix. If you adjust the environment dropdown box, you will be able to select injected web3. This will allow you to connect with metamask and then deploy your contracts.\u003c/p\u003e\n\u003cp\u003eWith gas costs being as expensive as they are now, we would recommend trying the contracts on any testnet network such as Kovan or alternatively on xDai chain (please follow the guide \u003ca href=\"https://www.xdaichain.com/for-users/wallets/metamask/metamask-setup\"\u003ehere\u003c/a\u003e to connect with metamask)\u003c/p\u003e\n\u003cp\u003eYou can receive xDai from the faucet at this \u003ca href=\"https://xdai-faucet.top/\"\u003elink\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eFor these networks, the conditional tokens contract has already been deployed and can be found at the following addresses:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMainnet: \u003ccode\u003e0xC59b0e4De5F1248C1140964E0fF287B192407E0C\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003exDai: \u003ccode\u003e0xCeAfDD6bc0bEF976fdCd1112955828E00543c0Ce\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRinkeby: \u003ccode\u003e0x36bede640D19981A82090519bC1626249984c908\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"},{id:10,href:"https://docs.just.win/docs/developer-guide/introduction/",title:"Introduction",description:"Answers to frequently asked questions.",content:"\u003cp\u003eOur github page is found at \u003ca href=\"https://github.com/abdullathedruid/lslmsr\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThere are five contracts included:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eLsLMSR.sol - the contract to create a prediction market automated market maker using liquidity sensitive LMSR.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eABDKMath64x64.sol - library enabling fixed point arithmetic (written by ABDK Consulting)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eConditionalTokens.sol - contract to create conditional tokens (written by Gnosis)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCTHelpers.sol - helper contract for conditional tokens (written by Gnosis)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFakeDai.sol - sample ERC20 token to be used for testing\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"},{id:11,href:"https://docs.just.win/docs/developer-guide/lslmsr/",title:"LsLMSR",description:"Regularly update the installed npm packages to keep your Doks website stable, usable, and secure.",content:"\u003cp\u003eWithin the LsLMSR there are six functions available for use:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eConstructor: necessary to initiate the prediction market\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSetup: necessary to adjust the parameters on creation and to fund the market maker\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBuy: utilised by traders when they wish to buy outcome tokens\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWithdraw: utilised by the market creator to withdraw their liquidity after the market has resolved\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCost: returns the total cost basis of the market maker\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePrice: returns the price to purchase a certain number of tokens on a particular outcome\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"},{id:12,href:"https://docs.just.win/docs/developer-guide/constructor/",title:"Constructor",description:"Solutions to common problems.",content:"\u003cp\u003e\u003cem\u003ecode goes here\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eWhen deploying the contract, you are required to supply two addresses:\u003c/p\u003e\n\u003cp\u003e_ct: The address pointing towards the conditional token contract.\u003c/p\u003e\n\u003cp\u003e_token:Â  The address pointing towards the ERC-20 token that will be used as the base currency for the market maker.\u003c/p\u003e\n\u003cp\u003eThe conditional tokens contract have already been deployed by the Gnosis team and can be found at the following addresses:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMainnet: \u003ccode\u003e0xC59b0e4De5F1248C1140964E0fF287B192407E0C\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003exDai: \u003ccode\u003e0xCeAfDD6bc0bEF976fdCd1112955828E00543c0Ce\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRinkeby: \u003ccode\u003e0x36bede640D19981A82090519bC1626249984c908\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"},{id:13,href:"https://docs.just.win/docs/developer-guide/buy/",title:"Buy",description:"Solutions to common problems.",content:"\u003cpre\u003e\u003ccode\u003efunction buy(\n    uint256 _outcome,\n    int128 _amount\n  ) public onlyAfterInit() returns (int128 _price){\n    int128 sum_total;\n    require(_outcome \u0026gt; 0);\n    require(CT.payoutDenominator(condition) == 0, 'Market already resolved');\n\n    for(uint j=0; j\u0026lt;numOutcomes; j++) {\n      if((_outcome \u0026amp; (1\u0026lt;\u0026lt;j)) != 0) {\n        q[j] = ABDKMath.add(q[j], _amount);\n        total_shares = ABDKMath.add(total_shares, _amount);\n      }\n    }\n\n    b = ABDKMath.mul(total_shares, alpha);\n\n    for(uint i=0; i\u0026lt; numOutcomes; i++) {\n      sum_total = ABDKMath.add(sum_total,\n        ABDKMath.exp(\n          ABDKMath.div(q[i], b)\n          ));\n    }\n\n    int128 new_cost = ABDKMath.mul(b,ABDKMath.ln(sum_total));\n    _price = ABDKMath.sub(new_cost,current_cost);\n    current_cost = new_cost;\n\n    uint token_cost = getTokenWei(token, _price);\n    uint n_outcome_tokens = getTokenWei(token, _amount);\n    require(IERC20(token).transferFrom(msg.sender, address(this), token_cost),\n      'Error transferring tokens');\n    IERC20(token).approve(address(CT), getTokenWei(token, _amount));\n    CT.splitPosition(IERC20(token), bytes32(0), condition,\n      getPositionAndDustPositions(_outcome), n_outcome_tokens);\n    uint pos = CT.getPositionId(IERC20(token),\n    CT.getCollectionId(bytes32(0), condition, _outcome));\n    CT.safeTransferFrom(address(this), msg.sender,\n      pos, n_outcome_tokens, '');\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function allows you to customise the parameters used by the market maker in employing the Ls LMSR algorithm.\u003c/p\u003e\n\u003cp\u003eThis function can only be called by the contract deployer and it is necessary to be called before it is possible to trade with the market maker.\u003c/p\u003e\n\u003cp\u003e_oracle: this is the address that is required to report the outcome of the prediction market at resolution. It can either be an externally owned account or a reference to another smart contract. This does not need to be the same as the person that deployed the contract. There are a variety of approaches that can be used for choosing the oracle and we discuss these further below.\u003c/p\u003e\n\u003cp\u003e_numOutcomes: an integer representing the number of discrete outcomes available for the market.\u003c/p\u003e\n\u003cp\u003e_subsidy: this represents the total amount of tokens that will be used to fund the market maker and can be viewed as the initial liquidity. The properties of the LsLMSR are such that choosing large numbers for _subsidy (ie where you fund the market maker with large amounts of capital) provides a tighter spread for traders, however results in higher potential losses (bounded loss is proportional to initial capital)\u003c/p\u003e\n\u003cp\u003e_overround: this represents the amount of profit that can be made by the market maker or the \u0026lsquo;houses edge\u0026rsquo;. It is expressed in \u0026lsquo;bips\u0026rsquo; where a value of 100 is equivalent to 1% profit. For reference, traditional book makers use an overround of between 5 and 10%. It is worth noting here that the calculations used by LsLMSR involve exponential arithmetic. Where the overround value is small, it is possible for the calculation to overflow (this is a limitation of the ethereum virtual machine). We would therefore recommend the minimum overround to be set at 3% but the actual minimum will be dependent on the number of outcomes available.\u003c/p\u003e\n\u003cp\u003eIn order for the oracle to report the outcome of the prediction market, it must call the function reportPayouts() found on the conditional tokens contract. This can either be done directly where the oracle is an externally owned account, or by a separate smart contract.\u003c/p\u003e\n\u003cp\u003eIt is possible to write additional smart contracts that can interact with chainlink nodes or kleros arbitration and parse this information in a manner that can be reported to the conditional tokens contract.\u003c/p\u003e\n\u003cp\u003eThrough the clever use of smart contracts, any information that can be brought on-chain can be used to create a prediction market.Â \u003c/p\u003e\n"},{id:14,href:"https://docs.just.win/docs/developer-guide/setup/",title:"Setup",description:"",content:"\u003cpre\u003e\u003ccode\u003efunction setup(\n    address _oracle,\n    uint _numOutcomes,\n    uint _subsidy,\n    uint _overround\n  ) public onlyOwner() {\n    require(init == false,'Already init');\n    require(_overround \u0026gt; 0,'Cannot have 0 overround');\n    CT.prepareCondition(_oracle, bytes32(uint256(address(this))), _numOutcomes);\n    condition = CT.getConditionId(_oracle, bytes32(uint256(address(this))), _numOutcomes);\n    console.logBytes32(bytes32(uint256(address(this))));\n\n    IERC20(token).safeTransferFrom(msg.sender, address(this), _subsidy);\n\n    numOutcomes = _numOutcomes;\n    int128 n = ABDKMath.fromUInt(_numOutcomes);\n    int128 initial_subsidy = getTokenEth(token, _subsidy);\n\n    int128 overround = ABDKMath.divu(_overround, 10000);\n    alpha = ABDKMath.div(overround, ABDKMath.mul(n,ABDKMath.ln(n)));\n    b = ABDKMath.mul(ABDKMath.mul(initial_subsidy, n), alpha);\n\n    for(uint i=0; i\u0026lt;_numOutcomes; i++) {\n      q.push(initial_subsidy);\n    }\n\n    init = true;\n\n    total_shares = ABDKMath.mul(initial_subsidy, n);\n    current_cost = cost();\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function allows you to customise the parameters used by the market maker in employing the Ls LMSR algorithm.\u003c/p\u003e\n\u003cp\u003eThis function can only be called by the contract deployer and it is necessary to be called before it is possible to trade with the market maker.\u003c/p\u003e\n\u003cp\u003e_oracle: this is the address that is required to report the outcome of the prediction market at resolution. It can either be an externally owned account or a reference to another smart contract. This does not need to be the same as the person that deployed the contract. There are a variety of approaches that can be used for choosing the oracle and we discuss these further below.\u003c/p\u003e\n\u003cp\u003e_numOutcomes: an integer representing the number of discrete outcomes available for the market.\u003c/p\u003e\n\u003cp\u003e_subsidy: this represents the total amount of tokens that will be used to fund the market maker and can be viewed as the initial liquidity. The properties of the LsLMSR are such that choosing large numbers for _subsidy (ie where you fund the market maker with large amounts of capital) provides a tighter spread for traders, however results in higher potential losses (bounded loss is proportional to initial capital)\u003c/p\u003e\n\u003cp\u003e_overround: this represents the amount of profit that can be made by the market maker or the \u0026lsquo;houses edge\u0026rsquo;. It is expressed in \u0026lsquo;bips\u0026rsquo; where a value of 100 is equivalent to 1% profit. For reference, traditional book makers use an overround of between 5 and 10%. It is worth noting here that the calculations used by LsLMSR involve exponential arithmetic. Where the overround value is small, it is possible for the calculation to overflow (this is a limitation of the ethereum virtual machine). We would therefore recommend the minimum overround to be set at 3% but the actual minimum will be dependent on the number of outcomes available.\u003c/p\u003e\n\u003cp\u003eIn order for the oracle to report the outcome of the prediction market, it must call the function reportPayouts() found on the conditional tokens contract. This can either be done directly where the oracle is an externally owned account, or by a separate smart contract.\u003c/p\u003e\n\u003cp\u003eIt is possible to write additional smart contracts that can interact with chainlink nodes or kleros arbitration and parse this information in a manner that can be reported to the conditional tokens contract.\u003c/p\u003e\n\u003cp\u003eThrough the clever use of smart contracts, any information that can be brought on-chain can be used to create a prediction market.Â \u003c/p\u003e\n"},{id:15,href:"https://docs.just.win/docs/developer-guide/withdraw/",title:"Withdraw",description:"Solutions to common problems.",content:"\u003cpre\u003e\u003ccode\u003efunction withdraw() public onlyAfterInit() onlyOwner() {\n    require(CT.payoutDenominator(condition) != 0, 'Market needs to be resolved');\n    uint[] memory dust = new uint256[](numOutcomes);\n    uint p = 0;\n    for (uint i=0; i\u0026lt;numOutcomes; i++) {\n      dust[i] = 1\u0026lt;\u0026lt;i;\n      /* console.log('Index', 1\u0026lt;\u0026lt;i); */\n      p = CT.getPositionId(IERC20(token), CT.getCollectionId(\n        bytes32(0), condition, 1\u0026lt;\u0026lt;i)\n        );\n    }\n    CT.redeemPositions(IERC20(token), bytes32(0), condition, dust);\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function can only be called by the user that deployed the contract and after the outcome of the prediction market has been reported. It converts all the tokens that the market maker has into collateral and then withdraws all the collateral.Â w\u003c/p\u003e\n"},{id:16,href:"https://docs.just.win/docs/developer-guide/price/",title:"Price",description:"Solutions to common problems.",content:"\u003cpre\u003e\u003ccode\u003efunction price(\n    uint256 _outcome,\n    int128 _amount\n  ) public view returns (int128) {\n    return cost_after_buy(_outcome, _amount) - current_cost;\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis function takes the same parameters as buy().\u003c/p\u003e\n\u003cp\u003eIt will tell you the price to buy that number of outcome tokens and is denominated in the base currency.\u003c/p\u003e\n\u003cp\u003eThis is also returned as a fixed point integer and so will need to be converted into a human readable value by a front end.\u003c/p\u003e\n\u003cp\u003eIt is worth mentioning that the price here is the price to buy all the tokens, so if you wish to buy 10Dai worth of tokens with three separate outcomes, you may expect the price here to be 3-4Dai.\u003c/p\u003e\n\u003cp\u003eIf you wish to calculate the price per token (and therefore an approximate for the implied probability) you can divide this by the number of tokens.\u003c/p\u003e\n"},{id:17,href:"https://docs.just.win/docs/developer-guide/cost/",title:"Cost",description:"Solutions to common problems.",content:"\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ecost\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"kr\"\u003epublic\u003c/span\u003e \u003cspan class=\"nx\"\u003eview\u003c/span\u003e \u003cspan class=\"nx\"\u003eonlyAfterInit\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"nx\"\u003ereturns\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eint128\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nx\"\u003eint128\u003c/span\u003e \u003cspan class=\"nx\"\u003esum_total\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003euint\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"nx\"\u003enumOutcomes\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"nx\"\u003esum_total\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eABDKMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eadd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003esum_total\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eABDKMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eexp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eABDKMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ediv\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"nx\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)));\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003eABDKMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003emul\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eABDKMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003esum_total\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis function returns the total trade volume of the market maker. This can be viewed as the total amount of money within the market maker. Note that it does not include the initial funding liquidity. Every time there is a trade, this number increases.\u003c/p\u003e\n"},{id:18,href:"https://docs.just.win/docs/developer-guide/",title:"Overview",description:"Help Doks.",content:""},{id:19,href:"https://docs.just.win/docs/tutorial/",title:"Contract v0.1",description:"Description.",content:""},{id:20,href:"https://docs.just.win/docs/overview/",title:"Title",description:"Description.",content:""},{id:21,href:"https://docs.just.win/docs/",title:"Docs",description:"Docs Doks.",content:""},];index.add(docs);userinput.addEventListener('input',show_results,true);suggestions.addEventListener('click',accept_suggestion,true);function show_results(){var value=this.value;var results=index.search(value,5);var entry,childs=suggestions.childNodes;var i=0,len=results.length;suggestions.classList.remove('d-none');results.forEach(function(page){entry=document.createElement('div');entry.innerHTML='<a href><span></span><span></span></a>';a=entry.querySelector('a'),t=entry.querySelector('span:first-child'),d=entry.querySelector('span:nth-child(2)');a.href=page.href;t.textContent=page.title;d.textContent=page.description;suggestions.appendChild(entry);});while(childs.length>len){suggestions.removeChild(childs[i])}}
function accept_suggestion(){while(suggestions.lastChild){suggestions.removeChild(suggestions.lastChild);}
return false;}}());